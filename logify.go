package logify

//TODO: fix README.md for the v3.0.0 release
import (
	"fmt"
	"os"
	"time"

	logify_colors "github.com/Jdcabreradev/logify/v3/colors"
	logify_enums "github.com/Jdcabreradev/logify/v3/enums"
)

// The Logger structure contains all the information and functionality needed to handle logging.
type Logger struct {
	module      string                  // Name of the module generating the logs.
	consumer    string                  // Name of the consumer or part of the application using the logger.
	env         logify_enums.LogifyMode // Environment in which the application runs (e.g., Developer, Deployment).
	logDirPath  *string                 // Directory path where log files will be saved.
	logFilePath string                  // Full path of the current log file.
	logFile     *os.File                // Pointer to the open log file.
}

// New creates a new instance of Logger with the specified module, consumer, environment, and log directory.
func New(module, consumer, logDirPath string, env logify_enums.LogifyMode) *Logger {
	var logFilePath string
	var logFile *os.File
	var err error

	// Create the log file only if we are not in Developer mode.
	if env != logify_enums.LogModeDev {
		if err = os.MkdirAll(logDirPath, 0664); err != nil {
			printError(err)
			return nil
		}

		timestamp := time.Now().Format("2006-01-02_15-04-05")
		logFilePath = fmt.Sprintf("%s/app_%s.log", logDirPath, timestamp)

		logFile, err = os.OpenFile(logFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			printError(err)
			if logFile != nil {
				logFile.Close()
			}
			return nil
		}
	}

	return &Logger{
		module:      module,
		consumer:    consumer,
		env:         env,
		logDirPath:  &logDirPath,
		logFilePath: logFilePath,
		logFile:     logFile,
	}
}

// Prints a formatted message to the standard output and saves it to the file if configured.
func (l *Logger) Log(logType logify_enums.LogType, message string) {
	switch l.env {
	case logify_enums.LogModeDev:
		l.printLog(logType, message, false)

	case logify_enums.LogModeRelease:
		if logType != logify_enums.DEBUG {
			l.printLog(logType, message, true)
		}

	case logify_enums.LogModeVerbose:
		l.printLog(logType, message, true)

	case logify_enums.LogModeHidden:
		if logType == logify_enums.INFO || logType == logify_enums.ERROR {
			l.printLog(logType, message, true)
		}
	}
}

// printLog handles the logic for printing and optionally saving logs to a file.
func (l *Logger) printLog(logType logify_enums.LogType, message string, saveToFile bool) {
	logTypeStr := logType.LogTypeParser()
	timestamp := time.Now().Format(time.DateTime)
	mode := l.env.LogifyModeParser()

	consoleMessage := fmt.Sprintf("[%s%s%s] [%s] [%s:%s] %s\n",
		logify_colors.LogColor[logType], logTypeStr, logify_colors.Reset,
		timestamp, l.consumer, mode, message)

	logFileMessage := fmt.Sprintf("[%s] [%s] [%s:%s] %s\n",
		logTypeStr, time.Now().Format(time.RFC3339),
		l.consumer, mode, message)

	fmt.Print(consoleMessage)

	if saveToFile {
		if _, err := l.logFile.WriteString(logFileMessage); err != nil {
			printError(err)
		}
	}
}

// Closes the log file if it is open.
func (l *Logger) Close() {
	if l.logFile != nil {
		err := l.logFile.Close()
		if err != nil {
			printError(err)
		}
	}
}

// printError handles primivite errors generated by the package itself.
func printError(err error) {
	errorMessage := fmt.Sprintf("[%s%s%s] [%s] [%s:%s] %s\n",
		logify_colors.Red,
		logify_enums.ERROR.LogTypeParser(),
		logify_colors.Reset,
		time.Now().Format(time.DateTime),
		"Logify",
		logify_enums.LogModeVerbose.LogifyModeParser(),
		err.Error(),
	)
	fmt.Print(errorMessage)
}
